# 第六天

## 有序数组的平方

给定一个数组，然后需要得到一个升序的平方数组，如果使用暴力法，即直接进行平方，然后进行排序得到结果。如果采用最快的快速排序，时间复杂度依旧是O(logn)

但是如果使用双指针就可以很好地减少时间复杂度，将其降低至O(n),核心思想就是利用双指针移动遍历所有数字，然后给新的数组按从大到小赋值

```go
func sortedSquares(nums []int) []int {
	n := len(nums)
	i, j, k := 0, n-1, n-1
	ans := make([]int, n)
	for i <= j {
		lm, rm := nums[i]*nums[i], nums[j]*nums[j]
		if lm > rm {
			ans[k] = lm
			i++
		} else {
			ans[k] = rm
			j--
		}
		k--
	}
	return ans
}
```

## 长度最小的子数组

​	为了满足>=目标的最小数组。====>>>滑动窗口

使用双指针进行移动，得到最终的长度

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口（边界加窗口内部），主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![leetcode_209](https://img-blog.csdnimg.cn/20210312160441942.png)

加点练习材料

把刚才的代码来实现一遍，就是说看的是别人的，写出来才是自己的！！

```go
func minSubArrayLen(target int, nums []int) int {
    left,right,length:=0,0,len(nums)
    res:=2<<12
    sum:=0
    for right<=length-1{
        // 确定右边界
        sum=sum+nums[right]
        // 移动左边界
        for sum>=target{
            //先计算长度再继续下一步
            if res>right-left+1{
                res=right-left+1
            } 
            sum-=nums[left]
            left++
        }
        right++
    }
    //确定已经更新到最小值，如果没有更新即没有达到要求的就返回0
    if res==2<<12{
        return 0
    }
    return res
}
```

自己总结一遍就是需要确认滑动窗口的边界，左右边界什么时候需要移动，怎么进行移动是需要关注的重点。在本题中就是外层循环确定右边界，内层进行长度匹配，得到最小长度，另外，在循环中均是完成当前操作后才进行移动边界指针。

### 水果成篮

```go
func totalFruit(fruits []int) int {
// 初始化
n,A,B,res:=len(fruits),fruits[0],fruits[0],0
left,right:=0,0
for right<n{
// 符合篮子的水果标准，继续装水果
    if A==fruits[right]||B==fruits[right]||A==B{
        // 更新一下答案
        if res<right-left+1{
            res=right-left+1
        }
        if A==B{
            //只有一个种类
            B=fruits[right]
        }
        //进入下一次循环
        right++
    }else{
        B=fruits[right]
        A=fruits[right-1]
        //找到符合标准的左边界
        for left=right-1;left>=0;left--{
            if A!=fruits[left]&&B!=fruits[left]{
                //确保左边界是与已有种类一致的
                break
            }
        }
        left++
    }}
    return res
}
```

这道题就是题有点难读懂，为什么这样说嘞，因为我看了一个半小时，就是这麽回事儿。这里其实滑动窗口的思维就淡花了不少，主要是将问题抽象化的能力。其实就是怎么移动边界的问题。

​	首先是右指针，什么时候移动呢？我觉得大多时候还是合法的时候才能移动右边，那什么又算是合法呢？其实就是接下来要放的水果应该是两种水果中的一个（篮子中已有的或者只有一种的话可以再随便加一种），合法的时候就需要更新一下最大子串的长度，然后进入下一个循环。而不合法的时候就需要将左边界更新至窗口内部只能有两种种类水果的地方。