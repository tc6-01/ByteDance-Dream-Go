

# 第九天

## 链表篇

### 删除链表的倒数第N个节点

em，有点点匪夷所思，最开始想的就是如果可以的话，那直接得到正数的位数不就ok了吗？还整这么花里胡哨的，不得不说还是的人家专业的会啊，首先就是如果得到正数的话，不知道链表的长度，如果要知道链表长度需要进行遍历，这就做了一点瞎搞。

​	这里使用的办法是双指针。内容大概就是首先让快指针先跑起来，跑n+1个位置，然后快慢一起跑，这样就能是的最后快指针到达链表末尾了，慢指针处于要删除的元素的上一个元素。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy:=&ListNode{Next:head}
    fast,slow:=dummy,dummy
    //快指针先移动
    for i:=0;i<n+1;i++{
        fast=fast.Next
    }
    //快慢一起移动
    for fast!=nil{
        fast=fast.Next
        slow=slow.Next
    }
    slow.Next=slow.Next.Next
    return dummy.Next
}
```

### 链表相交

​	我是真的没有想到哈，题目出得和他的例子根本就对应不上，但是咱是谁啊，咱可以满足她一切需求的男人啊。所以这里使用双指针来进行做答。首先就是得到两个链表的长度及其长度差，方便后面得到对齐的链表，也就是将长的链表与短的链表对齐，长短链表均从对齐的地方出发，进行遍历，如果遇到指针相等就退出遍历，这个似乎后直接返回就得到结果了。最后手撕代码。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    curA := headA
    curB := headB
    lenA, lenB := 0, 0
    // 求A，B的长度
    for curA != nil {
        curA = curA.Next
        lenA++
    }
    for curB != nil {
        curB = curB.Next
        lenB++
    }
    var step int
    var fast, slow *ListNode
    // 请求长度差，并且让更长的链表先走相差的长度
    if lenA > lenB {
        step = lenA - lenB
        fast, slow = headA, headB
    } else {
        step = lenB - lenA
        fast, slow = headB, headA
    }
    for i:=0; i < step; i++ {
        fast = fast.Next
    }
    // 遍历两个链表遇到相同则跳出遍历
    for fast != slow {
        fast = fast.Next
        slow = slow.Next
    }
    return fast
}
```

### 环形链表

​	就是说判断一下环形链表的入口元素，那么首先就是找到是否有环，如果有环的话，环的入口在哪里？怎么进行判断，其实这里有个贼好的证明方法（反正又不是我想出来的），就是采用双指针，将一个跑的快的指针和跑的慢的指针进行结合，如果快指针和慢指针在最后相遇了，那不就证明有环吗？这里说的快就是他的跨度大，一次跑两个或两个以上。然后进行环形链表入口的判断，这里用的是解方程的方法，首先给定三个关键的地理位置，分别是头节点，环形区域的入口，快慢指针相遇地方，然后分别设为x，y，z，那么最后有快慢指针相遇得。
$$
x+y=z+n(y+z)  ===>>>x=(n-1)*(y+z)+z ===》》》当n=1时，x=z
$$
也就是说从快慢指针相遇的地方进行移动，同时从头结点出发开始移动，最后两个指针相遇的地方就是要找的入口

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    fast,slow:=head,head
    for fast!=nil&&fast.Next!=nil{
        slow=slow.Next
        fast=fast.Next.Next
        if slow==fast{
            for slow!=head{
                slow=slow.Next
                head=head.Next
            }
            return head
        }
    }
    return nil
}
```

### 总结篇



<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img" style="zoom:200%;" />