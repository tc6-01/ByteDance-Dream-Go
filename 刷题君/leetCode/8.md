# 第八天

## 移除链表元素

好像需要区分一下头节点和正常节点的删除。不对劲，如果有区别的话，那为什么不给统一呢？所以可以用一个虚拟头节点，代替当前头结点的位置，然后头结点就变成了正常结点，删除就非常一致了。所以这就是迭代法（正常寻找对应的元素进行删除）

```go
func remove(head *ListNode , val int) * ListNode{
   // 创建虚拟头节点
    dummy := &ListNode{Next:head}
    for tem:=dummy;tem.Next!=nil;{
        if tem.Next.Val==val{
            tem.Next=tem.Next.Next
        }else{
            tem=tem.Next
        }
        return dummy.Next
    }
}
```

另外还有一种方法，递归法，所谓递归法就是明确出函数的目的，然后就一直进行递归，最后再回来处理。但是一定要提前确认的是递归的深度，要不然会一直进行下去。边界就是链表为空`head==nil`，然后就是递归内容了，需要确定的就是head的next，所以就递归的确认，如果需要删除就进行删除，否则就正常返回Next

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeElements(head *ListNode, val int) *ListNode {
    if head == nil {
        return head
    }
    head.Next = removeElements(head.Next, val)
    if head.Val == val {
        return head.Next
    }
    return head
}
```

## 实现链表的CRUD

没啥好说的其实，就是熟悉一下链表的数据结构，然后进行操作。

不得不说，数据结构设计的好，基本操作少一半，使用的是双向链表。

```go
type MyLinkedList struct {
	dummy *Node
}

type Node struct {
	Val  int
	Next *Node
	Pre  *Node
}

//仅保存哑节点，pre-> rear, next-> head,循环双向链表
/** Initialize your data structure here. */
func Constructor() MyLinkedList {
	rear := &Node{
		Val:  -1,
		Next: nil,
		Pre:  nil,
	}
	rear.Next = rear
	rear.Pre = rear
	return MyLinkedList{rear}
}

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
func (this *MyLinkedList) Get(index int) int {
	head := this.dummy.Next
	//head == this, 遍历完全
	for head != this.dummy && index > 0 {
		index--
		head = head.Next
	}
	//否则, head == this, 索引无效
	if 0 != index {
		return -1
	}
	return head.Val
}

/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
func (this *MyLinkedList) AddAtHead(val int) {
	dummy := this.dummy
	node := &Node{
		Val: val,
		//head.Next指向原头节点
		Next: dummy.Next,
		//head.Pre 指向哑节点
		Pre: dummy,
	}

	//更新原头节点
	dummy.Next.Pre = node
	//更新哑节点
	dummy.Next = node
	//以上两步不能反
}

/** Append a node of value val to the last element of the linked list. */
func (this *MyLinkedList) AddAtTail(val int) {
	dummy := this.dummy
	rear := &Node{
		Val: val,
		//rear.Next = dummy(哑节点)
		Next: dummy,
		//rear.Pre = ori_rear
		Pre: dummy.Pre,
	}
	dummy.Pre.Next = rear
	//update dummy
	dummy.Pre = rear
	//以上两步不能反
}

/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
func (this *MyLinkedList) AddAtIndex(index int, val int) {
	head := this.dummy.Next
	//head = MyLinkedList[index]
	for head != this.dummy && index > 0 {
		head = head.Next
		index--
	}
	node := &Node{
		Val: val,
		//node.Next = MyLinkedList[index]
		Next: head,
		//node.Pre = MyLinkedList[index-1]
		Pre: head.Pre,
	}
	//MyLinkedList[index-1].Next = node
	head.Pre.Next = node
	//MyLinkedList[index].Pre = node
	head.Pre = node
	//以上两步不能反
}

/** Delete the index-th node in the linked list, if the index is valid. */
func (this *MyLinkedList) DeleteAtIndex(index int) {
	//链表为空
	if this.dummy.Next == this.dummy {
		return
	}
	head := this.dummy.Next
	//head = MyLinkedList[index]
	for head.Next != this.dummy && index > 0 {
		head = head.Next
		index--
	}
	//验证index有效
	if index == 0 {
		//MyLinkedList[index].Pre = index[index-2]
		head.Next.Pre = head.Pre
		//MyLinedList[index-2].Next = index[index]
		head.Pre.Next = head.Next
		//以上两步顺序无所谓
	}
}
```

## 反转链表

就是直接将next只想更改一下，一般采取双指针法。大概就是首先记录一下当前指针对应的节点的下一个节点，然后将当前节点的指向反转，然后更新一下当前节点和当前节点的下一个节点。

分为迭代和递归两种用法。首先是迭代法。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var temp,pre,cur *ListNode
    cur=head
    for cur!=nil{
        temp=cur.Next
        cur.Next=pre
        pre=cur
        cur=temp
    }
    return pre
}
```

递归法

```go
func reverseList(head *ListNode) *ListNode {
    return reverse(head,nil)
}
func reverse(cur *ListNode , pre *ListNode) *ListNode{
    if cur==nil{
        return pre
    }
    temp:=cur.Next
    cur.Next=pre
    return reverse(temp,cur)
}
```

这里还是有一点点小问题，理解是理解了，但是总归是写不出来的，问题出现在哪儿呢？大概就是不知道递归部分应该怎么写，边界是挺清晰的，但是内部实现就有一点点问题，所以到底应该怎么实现嘞？想一下递归主要实现的是一个重复的部分，那么该题中重复的部分不就是反转元素吗？所以把反转部分放进递归内部代码，然后递归的参数设置为更新内容，所以需要放置新的cur和pre，大概这样就好理解多了嘛！

## 交换链表元素（多个元素一起）

​	其实就是每两个元素进行交换位置，那没问题就在这里了，重点是两个元素，所以我们的重点就是关注这里的两个元素，首先是确定这两个元素是否合法，然后进行交换，最后进行更新，一气呵成，丝毫不推泥带水，我丢，这个是真的丝滑。那么有了这个迭代版本的，其实递归版本的也就出来了，首先是边界确认，就是说合法的两个元素，然后就是更新值，每次头节点跳跃两个位置，然后进行交换。

```go
//迭代
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    dummy:=&ListNode{0,head}
    cur:=dummy
    for cur.Next!=nil&&cur.Next.Next!=nil{
        temp:=cur.Next
        temp1:=cur.Next.Next
        cur.Next=temp1
        temp.Next=temp1.Next
        temp1.Next=temp
        cur=temp
    }
    return dummy.Next
}
//递归
func swapPairs(head *ListNode) *ListNode {
    if head==nil||head.Next==nil{
        return head
    }
    next:=head.Next
    head.Next=swapPairs(next.Next)
    next.Next=head
    return next
}
```

