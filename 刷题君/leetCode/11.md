# 第11天

## 字符串

### 字符串反转	

怎么说呢，我的感觉是这不就是数组的题拿到了字符串里面做吗？换句话说，字符串就是另外一个数组啊，换个高级点的版本意思就是说，如果可以，你可以有一个每隔k个反转k个，末尾不够k个时全部反转的新型反转做法；这样就会显得高级一点，那具体做法其实就是。每次新增2k个，然后在新增区间里寻找需要反转的内容，这样逻辑就全部在判断翻转内容上面了。

​	另外发现一个go语言特性的东西`...`**使用在数组中**,**打散Slice**,**变长的函数参数**,

### 替换空格

​	这道题呢，em，说实话，重点不在解题而是在优化解法。解题其实很简单，只需要简简单单的用一个新的数组来记录一下，如果是空格就加上那个‘%20‘，如果不是，就加上原来就有的内容，这样就可以得到最终的结果，但这样就多了一个申请数组的开辟空间

首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：

i指向新长度的末尾，j指向旧长度的末尾。

![gif](https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif)

有同学问了，为什么要从后向前填充，从前向后填充不行么？

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。

2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

### 颠倒字符串中的单词

   就是说非常深刻的体会是，当自己想的时候是一回事，写的时候又是一回事，忽然你就会觉得动手能力和你的口头能力是不应该放在一起比较的。所以慢一点，等做出来之后再说。

​	这道题同样与上道类似，考虑的是不使用辅助空间，那么这里就用同样的，缩小空间，然后反转整个字符串，最后反转每个单词（整挺好），那么问题来了，怎么用呢？

1. 缩小空间

   首先是不是要找出来哪里有空间给我们缩小，首先是单词前面的空格，然后单词间的多余空间，最后就是单词尾部的空间。这里采用双指针的方式-----fast，slow两个指针，fast指针用来遍历整个字符数组（一般牵涉到字符串，自动把字符串转换为字符数组，方便处理），slow来记录有效值。

   单词前面的空格，使用fast移动方式过滤，怎样得到对应条件呢？这里的想法是在整个数组中，只要为空格，就继续

   ```go
   for len(strings)>0&&fast<len(strings)&&strings[fast]==' '{
       fast++
   }
   ```

   单词间的多余空格，采用continue+fast移动方式过滤掉，这里的条件是两个连续的空格出现，过滤掉最新的一个,然后正常的记录呢，就使用slow记录下来

   ```go
   for ;fast<len(b);fast++{
   	if fast-1>0&&strings[fast]==strings[fast-1]&&strings[fast]==' '{
       	continue
   	}
       strings[slow]=strings[fast]
       slow++
   }
   //这里提个小建议，就是使用到fast-1的时候，一定要注意fast-1>0
   ```

2. 反转整个字符串

   直接调用之前用到的反转字符串，双指针申请出战

3. 反转每个单词

   这里的每个单词反转，其实就是字符串的空格前的字符反转，类似于那个固定字符距离反转，所以可以联系以下实际，将2，3两个需求合成一个函数，将参数改为数组，left，right

```go
func reverse(b *[]byte,left,right int){
    for left < right {
		(*b)[left], (*b)[right] = (*b)[right], (*b)[left]
		left++
		right--
	}
}
```

### 左旋转字符串

​	其实到了这里才准确的感受到每个题目之间的联系，有的题目就是之前的题目的合集，比如上一道题，然后就开始头脑风暴。这道题其实有一种解法是利用替换空格的做法，将字符数组扩容，然后完成反转之后，再进行删除。或者类似于字符串反转的玩法，先记录需要反转的内容，反转之后进行记录，再利用双指针将后面的元素前移，再把最后的反转后元素放回去。但是这两种方法要么需要开辟新空间，要么需要高的时间复杂度。所以在原子串上进行操作才是最nice的。

​	这里采取与颠倒字符串中的单词类似的操作，先局部反转，然后再整体操作，会有意想不到的结果，就像先整体后局部达到了反转每个单词的效果。

![img](https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png)

```go
func reverseLeftWords(s string, n int) string {
    ss:=[]byte(s)
    //1.reverse the son string
    reverse(&ss , 0, n-1)
    reverse(&ss,n,len(ss)-1)
    //2.reverse the whole string
    reverse(&ss,0,len(ss)-1)
    return string(ss)
}
func reverse(b *[]byte,left,right int){
    for left<right{
        (*b)[left],(*b)[right]=(*b)[right],(*b)[left]
        left++
        right--
    }
}
```

就是说终于可以让我简单一次。