# SecondDay

## 寻找两个正序数组的中位数

​	这道题其实就是一个混合知识点的考察，首先将两个数组合并，然后进行排序，最后再求解中位数。

给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：

- 使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。


- 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。


假设两个有序数组的长度分别为 m 和 n，上述两种思路的复杂度如何？

第一种思路的时间复杂度是 `O(m+n)`，空间复杂度是 `O(m+n)`。第二种思路虽然可以将空间复杂度降到 `O(1)`，但是时间复杂度仍是`O(m+n)`。

如何把时间复杂度降低到 `O(log(m+n))` 呢？如果对时间复杂度的要求有 `log`，通常都需要用到二分查找，这道题也可以通过二分查找实现。

​	最后，我真的觉得我不太适合学算法，这也太难了吧。

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    totalL:=len(nums1)+len(nums2)
    if totalL%2==1{
        midIndex:=totalL/2
        return float64(getMidArray(nums1,nums2,midIndex+1))
    }
    midIndex1, midIndex2 := totalL/2 - 1, totalL/2
    return float64(getMidArray(nums1,nums2,midIndex1+1)+getMidArray(nums1,nums2,midIndex2+1))/2.0
}
func getMidArray(nums1,nums2 []int,k int)int{
    // 维护数组的中位数索引值一半
    index1,index2:=0,0
    //维护数组丢弃之后新的起始位置
    for{
        //程序出口
        if index1==len(nums1){
            return nums2[index2+k-1]
        }
        if index2==len(nums2){
            return nums1[index1+k-1]
        }
        if k==1{
            return min(nums1[index1],nums2[index2])
        }
        // 循环采取最小k值
        M:=k/2
        Index1:=min(index1+M,len(nums1))-1
        Index2:=min(index2+M,len(nums2))-1
        // 采用最小值，就是为了防止数组越界
        page1,page2:=nums1[Index1],nums2[Index2]
        // 开始进行丢弃
        if page1<=page2{
            k-=Index1-index1+1
            index1=Index1+1
        }else{
            k-=Index2-index2+1
            index2=Index2+1
        }
    }
    return 0
}
func min(x,y int)int{
    if x<y{
        return x
    }
    return y
}
```

​	寻找第k小的数，属于是，而且这里使用的是用不同的变量来维护不同的属性值，打死我都想不到有这种操作的好吗，就是比如用index1来维护每次数组需要进行变化的k，用Index1来维护数组丢弃之后新的起始位置，这可叫人怎么想的到嘛，😔

## 删除链表？？？（返回头节点）

​	在删除的同时还要返回删完之后的头节点，似乎有点回不去，那咋整，只有一个办法就是采用引用的方式，直接返回之前就引用好的链表指针，然后就可以得到心心念念的头节点。

```go
I:=&ListNode{0,head}
```

