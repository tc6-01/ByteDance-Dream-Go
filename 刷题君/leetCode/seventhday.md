# 第七天

## 螺旋矩阵

解题思路：就是使用for循环进行顺时针元素打印，最后输出结果。但是关键就是怎样保证不会扰乱打印的顺序。

从左到有，从上到下，从右到左，从下到上，另外需要保证的是不能重复元素，所以这里可以对元素的步长进行修正`正方形矩阵`，但如果是长方形矩阵呢？所以必须要保证处理好步长，否则就会造成元素重复以至于最后非常混乱。

理论合理，开始实践。

在开始之前，需要确定的几个关键，首先是起始（初始化），接着是边界（怎样判断结束循环）.

```go
type pair struct{ x, y int }
var dirs = []pair{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} // 右下左上

func generateMatrix(n int) [][]int {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
    }
    row, col, dirIdx := 0, 0, 0
    for i := 1; i <= n*n; i++ {
        matrix[row][col] = i
        dir := dirs[dirIdx]
        if r, c := row+dir.x, col+dir.y; r < 0 || r >= n || c < 0 || c >= n || matrix[r][c] > 0 {
            dirIdx = (dirIdx + 1) % 4 // 顺时针旋转至下一个方向
            dir = dirs[dirIdx]
        }
        row += dir.x
        col += dir.y
    }
    return matrix
}
```

## 数组总结

### 二分法

​	大概就是从最左最右分别开始进行代码逻辑，这样的好处就是原来暴力搜索O(n^2)的时间复杂度可以被二分法降到O（logn）

### 双指针

​	这里的双指针一般指的就是快慢指针，可以进行数组元素的“删除”，因为数组是连续的存储单元，是不会存在被删除这一刷的，所以有可能的只是元素被覆盖。那么使用慢指针进行记录后来的位置，快指针记录最新的元素位置，当然这里的前提是，数组是有序的，另外是删除元素或者是将固定的元素扔到固定的位置。这里瞧瞧来解释一下为什么，因为数组的删除是覆盖元素，所以不需要记录已经覆盖的元素，另外移动固定的元素，是因为已知元素可以最后进行赋值。

### 滑动窗口

​	整个滑动窗口其实就是双指针，只是使用左右指针确认出来左右边界。那么问题就是什么时候移动边界，怎样移动边界。就这两个问题。

### 模拟行为

​	人家说模拟的最高境界就是代码的掌控能力，没有过高的算法能力，大概就是到了对的地方。